use Prelude

#javascript "
  let addEventListener = el => sym => ev => data => {
    el[ev] = () => {
      if(window.events && window.events.get(sym)) {
        let [fn, state] = window.events.get(sym);
        window.events.set(sym, [fn, fn(data, state)])
      }
    }
  }

  let addListener = symbol => fn => def => {
      if(window.events == undefined) {
          window.events = new Map();
      }
      window.events.set(symbol, [(a,b) => fn(a)(b), def])
  }
"

type List x =
  | Cons x (List x)
  | Nil

let unwords : List String -> String
  | List.Cons x (List.Cons y xs) => x ++ " " ++ unwords (List.Cons y xs)
  | List.Cons x List.Nil         => x
  | List.Nil                     => ""

let range (from: Int) (to: Int) : List Int =
  when from != to is
    True  => List.Cons from (range (from + 1) to)
    False => List.Nil

let forEach (f: x -> ()) : List x -> ()
  | List.Nil       => ()
  | List.Cons x xs => do
      f x
      forEach f xs

let reverseListHelper : List x -> List x -> List x
  | List.Nil,       ys => ys
  | List.Cons x xs, ys => reverseListHelper xs (List.Cons x ys)

let reverseList (x: List x) : List x =
  reverseListHelper x List.Nil

let deleteFromList : List x -> x -> List x
  | List.Nil,       y => List.Nil
  | List.Cons x xs, y => 
      when x == y is
        True  => deleteFromList xs y
        False => List.Cons x (deleteFromList xs y)  

let flip : (a -> b -> c) -> b -> a -> c
  | f, b, a => f a b

let fold : (b -> a -> b) -> b -> List a -> b
  | f, acc, List.Nil       => acc 
  | f, acc, List.Cons x xs => fold f (f acc x) xs

let difference : List x -> List x -> List x = 
  fold deleteFromList

let concatList : List x -> List x -> List x
  | List.Cons x xs, ys => List.Cons x (concatList xs ys)
  | List.Nil      , ys => ys

let listMap (f: a -> b) : List a -> List b
  | List.Cons x xs => List.Cons (f x) (listMap f xs)
  | List.Nil       => List.Nil

type AttributePatch msg =
  | Add (Attribute msg)
  | Remove (Attribute msg)

type Patch msg =
  | Add (Html msg)
  | Remove
  | Update (List (Patch msg)) (List (AttributePatch msg))
  | Replace (Html msg)
  | NoPatch

type Attribute msg =
  | Id String 
  | ClassList (List String) 
  | OnClick msg

type Node msg = {
  tag        : String,
  attributes : List (Attribute msg),
  children   : List (Html msg)
}

type Html msg = 
  | Node (Node msg) 
  | Text String

-- Diffing

let diffChildren : List (Html msg) -> List (Html msg) -> List (Patch msg) -> List (Patch msg)
  | List.Nil      , List.Nil      , acc => reverseList acc
  | List.Cons x xs, List.Nil      , acc => diffChildren xs List.Nil (List.Cons Patch.Remove acc)
  | List.Nil      , List.Cons y ys, acc => diffChildren List.Nil ys (List.Cons (Patch.Add y) acc)
  | List.Cons x xs, List.Cons y ys, acc => diffChildren xs ys       (List.Cons (diff x y) acc)

let diffAttrs (old: List (Attribute msg)) (new1: List (Attribute msg)) : List (AttributePatch msg) =
  concatList (listMap AttributePatch.Remove (difference old new1))
             (listMap AttributePatch.Add    (difference new1 old))

let diff : Html msg -> Html msg -> Patch msg 
  | Html.Node node, Html.Text text  => Patch.Replace (Html.Text text)
  | Html.Text text, Html.Node node  => Patch.Replace (Html.Node node)
  | Html.Text text, Html.Text text1 => 
    when text == text1 is
      True  => Patch.NoPatch
      False => Patch.Replace (Html.Text text1)
  | Html.Node node, Html.Node node1 =>
    when node.tag != node1.tag is
      True  => Patch.Replace (Html.Node node1)
      False => do
        let children   = diffChildren node.children node1.children List.Nil
        let attributes = diffAttrs node.attributes node1.attributes
        Patch.Update children attributes 

-- Bindings

type GenericNode
type NodeElement
type TextElement
type Children
type Symbol msg model

type Element = 
  | Node NodeElement
  | Text TextElement

external createNode           : String -> NodeElement                   = "document.createElement"
external createText           : String -> NodeElement                   = "document.createTextNode"
external setAttribute         : NodeElement -> String -> String -> ()   = "(el => attr => val => el.setAttribute(attr, val))"
external appendChild          : NodeElement -> GenericNode -> ()        = "(el => child => el.appendChild(child))"
external getParent            : GenericNode -> NodeElement              = "(child) => child.parentNode"
external remove               : GenericNode -> ()                       = "(el) => el.remove()"
external replaceWith          : GenericNode -> GenericNode -> ()        = "(old => neww => old.replaceWith(neww))"
external removeAttribute      : NodeElement -> String -> ()             = "(el => attr => el.removeAttribute(attr))"
external prim_getElementById  : String -> NodeElement                   = "(id => document.getElementById(id))"
external prim_getChildren     : NodeElement -> Children                 = "(el => el.childNodes)"
external childLength          : Children -> Int                         = "(el => el.length)"
external idxChild             : Children -> Int -> GenericNode          = "(child => n => child[n])"
external createSymbol         : forall a b. String -> Symbol a b        = "(name => Symbol(name))"
external isNullOrUndefined    : forall a. a -> Bool                     = "(x => x === null || x === undefined ? 1 : 0)"

external addEventListener     : forall a b. GenericNode -> Symbol a b -> String -> a -> () = "addEventListener"
external addListener          : forall a b c. Symbol a b -> (a -> c -> c) -> c -> ()       = "addListener"
external removeListener       : NodeElement -> String -> ()                                = "(el => attr => {el[attr] = undefined})"

type State model msg = {
  model: model,
  view: Html msg
}

let createTextNode (s: String) : TextElement = trustMe (createText s)

let toGeneric : Element -> GenericNode
  | Element.Node x => trustMe x
  | Element.Text t => trustMe t

let toText (x: GenericNode) : Element = Element.Text (trustMe x)
let toNode (x: GenericNode) : Element = Element.Node (trustMe x)

let getChildren (element: NodeElement) : List GenericNode = do
  let children = prim_getChildren element
  let length   = childLength children
  listMap (idxChild children) (range 0 length)

let getElementById (x: String) : Option NodeElement = do
  let res = prim_getElementById x
  when isNullOrUndefined res is
    True  => None 
    False => Some res

-- Render

let renderAttribute (symbol: Symbol msg model) (parent: NodeElement) : Attribute msg -> ()
  | Attribute.Id i              => setAttribute parent "id" i
  | Attribute.ClassList classes => setAttribute parent "className" (unwords classes)
  | Attribute.OnClick msg       => addEventListener (trustMe parent) symbol "onclick" msg

let renderNode (symbol: Symbol msg model) (node: Node msg) : NodeElement = do
  let parent = createNode node.tag
  forEach (\a => appendChild parent (render symbol a)) node.children
  forEach (renderAttribute symbol parent) node.attributes
  parent

let render (symbol: Symbol msg model) : Html msg -> GenericNode
  | Html.Node node => trustMe (renderNode symbol node)
  | Html.Text text => trustMe (createTextNode text)

-- Patching


let deleteAttribute (element: NodeElement) : (Attribute msg) -> () 
  | Attribute.OnClick _   => removeListener element "onevent"
  | Attribute.Id _        => removeAttribute element "id"
  | Attribute.ClassList _ => removeAttribute element "className"

let patchAttributes (symbol: Symbol msg model) (element: NodeElement) : List (AttributePatch msg) -> ()
  | List.Nil => ()
  | List.Cons (AttributePatch.Add attr) attrs => do
       renderAttribute symbol element attr
       patchAttributes symbol element attrs
  | List.Cons (AttributePatch.Remove attr) attrs => do
       deleteAttribute element attr
       patchAttributes symbol element attrs

let patchChildren (symbol: Symbol msg model) (parent: GenericNode) : List GenericNode -> List (Patch msg) -> ()
  | List.Cons x xs, List.Cons p ps => do
      patch symbol x p
      patchChildren symbol parent xs ps
  | List.Nil, List.Cons p ps => do
      patch symbol parent p
      patchChildren symbol parent List.Nil ps
  | List.Nil     , List.Nil => ()
  | List.Cons _ _, List.Nil => ()

let patch (symbol: Symbol msg model) (parent: GenericNode) : Patch msg -> ()
  | Patch.NoPatch => ()
  | Patch.Replace html => do
      let res = render symbol html
      replaceWith (trustMe parent) res
  | Patch.Update children attrs => do
      let domChildren = getChildren (trustMe parent)
      patchChildren symbol parent domChildren children
      patchAttributes symbol (trustMe parent) attrs
  | Patch.Add element => do
      let res = render symbol element
      appendChild (trustMe parent) res
  | Patch.Remove => 
      remove parent

-- Start

let rootUpdater (symbol: Symbol msg model) (view: model -> Html msg) (update: model -> msg -> model)
                (parent: NodeElement) (msg: msg) (state: State model msg) : State model msg = do
  let newModel = update state.model msg
  let newView  = view newModel
  patch symbol (trustMe parent) (diff state.view newView)
  State { model = newModel, view = newView }

let start (view: model -> Html msg) (update: model -> msg -> model) (initial: model) : () = do
  when getElementById "main" is
    None      => log "cannot find main"
    Some main => do
      let symbol   = createSymbol "events"
      let html     = view initial
      let rendered = render symbol html
      appendChild (trustMe main) rendered
      let state = State { model = initial, view = html }
      addListener symbol (rootUpdater symbol view update (trustMe rendered)) state

-- Elements

let mk (tag: String) (attrs: List (Attribute msg)) (html: List (Html msg)) : Html msg =
  Html.Node (Node { tag = tag, attributes = attrs, children = html })

let div    : List (Attribute msg) -> List (Html msg) -> Html msg = mk "div"
let p      : List (Attribute msg) -> List (Html msg) -> Html msg = mk "p"
let button : List (Attribute msg) -> List (Html msg) -> Html msg = mk "button"
let text   : String -> Html msg                                  = Html.Text

-- App

type Msg = 
  | Increment
  | Decrement

let update (x: Int) : Msg -> Int
  | Msg.Increment => x + 1
  | Msg.Decrement => x - 1

let view (model: Int) : Html Msg = do
  let button2 = (button (List.Cons (Attribute.OnClick Msg.Increment) List.Nil) (List.Cons (text "increment") List.Nil))
  let point   = (p List.Nil (List.Cons (text ("falling " ++ (intToString model))) List.Nil))
  let button3 = (button (List.Cons (Attribute.OnClick Msg.Decrement) List.Nil) (List.Cons (text "decrement") List.Nil))
  div (List.Cons (Attribute.Id "pudim") List.Nil) (List.Cons button2 (List.Cons point (List.Cons button3 List.Nil)))

let main = do
  start view update 0